use std::{any::TypeId, io::Cursor};

use anyhow::{bail, Result};
use byteorder::{LittleEndian, ReadBytesExt};
use vivibin::{Endianness, ReadDomain, Readable, Reader};

#[derive(Clone, Copy)]
struct Format;

impl Format {
    pub fn read_i32(reader: &mut impl Reader) -> Result<i32> {
        let mut bytes: [u8; 4] = Default::default();
        reader.read(&mut bytes)?;
        
        Ok(match Self.endianness() {
            Endianness::Little => i32::from_le_bytes(bytes),
            Endianness::Big => i32::from_be_bytes(bytes),
        })
    }
    
    pub fn read_u32(reader: &mut impl Reader) -> Result<u32> {
        let mut bytes: [u8; 4] = Default::default();
        reader.read(&mut bytes)?;
        
        Ok(match Self.endianness() {
            Endianness::Little => u32::from_le_bytes(bytes),
            Endianness::Big => u32::from_be_bytes(bytes),
        })
    }
}

impl ReadDomain for Format {
    type Flags = ();
    type Pointer = u32;

    fn endianness(self) -> Endianness {
        Endianness::Little
    }
    
    fn read<T: Clone + 'static>(self, reader: &mut impl Reader) -> Result<Option<T>> {
        let result: Option<T>;
        let type_id = TypeId::of::<T>();
        
        // this can be auto generated by a macro super easily
        // this should also hopefully? get otimized out
        // at least once TypeId::of becomes a stable const fn
        if type_id == TypeId::of::<i32>() {
            let value = Self::read_i32(reader)?;
            
            result = Some(unsafe { (*((&value as *const i32) as *const T)).clone() });
        } else if type_id == TypeId::of::<u32>() {
            let value = Self::read_u32(reader)?;
            
            result = Some(unsafe { (*((&value as *const u32) as *const T)).clone() });
        } else {
            result = None;
        }
        
        Ok(result)
    }
}

#[derive(Debug)]
struct Vec3 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}

impl Vec3 {
    pub fn new(x: f32, y: f32, z: f32) -> Vec3 {
        Vec3 { x, y, z }
    }
}

impl Readable for Vec3 {
    fn from_reader(reader: &mut impl Reader, domain: impl ReadDomain) -> Result<Self> {
        let x = match domain.read::<f32>(reader)? {
            Some(x) => x,
            None => f32::from_reader(reader, domain)?,
        };
        let y = match domain.read::<f32>(reader)? {
            Some(y) => y,
            None => f32::from_reader(reader, domain)?,
        };
        let z = match domain.read::<f32>(reader)? {
            Some(z) => z,
            None => f32::from_reader(reader, domain)?,
        };
        
        Ok(Vec3::new(x, y, z))
    }
}



fn main() -> Result<()> {
    const VEC3_BYTES: [u8; 12] = [ 0, 0, 0x80, 0x3f, 0, 0, 0, 0x40, 0, 0, 0, 0x3f ];
    let mut cursor: Cursor<&[u8]> = Cursor::new(&VEC3_BYTES);
    let vec = Vec3::from_reader(&mut cursor, Format)?;
    println!("Hello World {:?}", vec);
    Ok(())
}
