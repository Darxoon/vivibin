use std::{
    any::TypeId, io::{Cursor, Write}, marker::PhantomData, mem::{transmute, ManuallyDrop}, ptr::read
};

use anyhow::{anyhow, Result};
use vivibin::{
    pointers::PointerZero32, scoped_reader_pos, CanRead, CanWrite, EndianSpecific, Endianness, HeapCategory, ReadDomain, ReadDomainExt, Readable, Reader, SimpleWritable, Writable, WriteCtx, WriteDomain, WriteDomainExt, Writer
};

// typedef for more convenient access
type Pointer = PointerZero32;

#[derive(Clone, Default)]
struct FormatCgfx<C: HeapCategory>(PhantomData<C>); // cgfx is an actual data type btw and the main reason I did this (3DS related)

impl<C: HeapCategory> FormatCgfx<C> {
    pub fn read_i32(reader: &mut impl Reader) -> Result<i32> {
        let mut bytes: [u8; 4] = Default::default();
        reader.read(&mut bytes)?;
        
        Ok(match Self::default().endianness() {
            Endianness::Little => i32::from_le_bytes(bytes),
            Endianness::Big => i32::from_be_bytes(bytes),
        })
    }
    
    pub fn write_i32(ctx: &mut impl WriteCtx, value: i32) -> Result<()> {
        let bytes = match Self::default().endianness() {
            Endianness::Little => value.to_le_bytes(),
            Endianness::Big => value.to_be_bytes(),
        };
        
        ctx.write(&bytes)?;
        Ok(())
    }
    
    pub fn read_u32(reader: &mut impl Reader) -> Result<u32> {
        let mut bytes: [u8; 4] = Default::default();
        reader.read(&mut bytes)?;
        
        Ok(match Self::default().endianness() {
            Endianness::Little => u32::from_le_bytes(bytes),
            Endianness::Big => u32::from_be_bytes(bytes),
        })
    }
    
    pub fn write_u32(ctx: &mut impl WriteCtx, value: u32) -> Result<()> {
        let bytes = match Self::default().endianness() {
            Endianness::Little => value.to_le_bytes(),
            Endianness::Big => value.to_be_bytes(),
        };
        
        ctx.write(&bytes)?;
        Ok(())
    }
    
    pub fn read_relative_ptr(reader: &mut impl Reader) -> Result<Pointer> {
        let pos = reader.position()?;
        let raw_ptr = u32::from_reader(reader, Self::default())?;
        Ok(if raw_ptr != 0 { Pointer::new(pos as u32 + raw_ptr) } else { Pointer::new(0) })
    }
    
    pub fn write_relative_ptr(writer: &mut impl Writer, value: Pointer) -> Result<()> {
        let relative = value.value() - writer.position()? as u32;
        relative.to_writer_simple(writer, Self::default())?;
        Ok(())
    }
    
    pub fn read_str(reader: &mut impl Reader) -> Result<String> {
        // reads a boxed string and not an inline string despite read_boxed's existence
        // because inline strings are never used in this format so this is 100x a more
        // sensible default
        let ptr = Self::read_relative_ptr(reader)?;
        
        scoped_reader_pos!(reader); // jump to pointer will be undone in destructor
        reader.set_position(ptr)?;
        
        Ok(reader.read_c_str()?)
    }
    
    pub fn write_str(ctx: &mut impl WriteCtx, value: &str) -> Result<()> {
        let token = ctx.allocate_next_block(move |ctx| {
            ctx.write_c_str(value)?;
            Ok(())
        })?;
        
        ctx.write_token::<4>(token)?;
        Ok(())
    }
    
    pub fn read_vec<T, R: Reader>(reader: &mut R, read_content: impl Fn(&mut R) -> Result<T>) -> Result<Vec<T>> {
        let count = Self::read_u32(reader)?;
        let content = Self::default().read_box(reader, |reader, _| {
            let mut result = Vec::with_capacity(count as usize);
            
            for _ in 0..count {
                result.push(read_content(reader)?);
            }
            
            Ok(result)
        })?;
        
        Ok(match content {
            Some(content) => content,
            None => Vec::new(),
        })
    }
}

// https://github.com/rust-lang/rust/issues/26925
impl<C: HeapCategory> Copy for FormatCgfx<C> {}

impl<C: HeapCategory> EndianSpecific for FormatCgfx<C> {
    fn endianness(self) -> Endianness {
        Endianness::Little
    }
}

impl<C: HeapCategory> ReadDomain for FormatCgfx<C> {
    type Pointer = Pointer;

    fn read_unk<T: 'static>(self, reader: &mut impl Reader) -> Result<Option<T>> {
        let result: Option<T>;
        // TODO: use ConstTypeId again
        let type_id = TypeId::of::<T>();
        
        // this can be auto generated by a macro super easily
        // this should also hopefully? get otimized out
        // at least once TypeId::of becomes a stable const fn
        if type_id == TypeId::of::<i32>() {
            let value = ManuallyDrop::new(Self::read_i32(reader)?);
            
            result = Some(unsafe { read(transmute::<&i32, &T>(&value)) });
        } else if type_id == TypeId::of::<u32>() {
            let value = ManuallyDrop::new(Self::read_u32(reader)?);
            
            result = Some(unsafe { read(transmute::<&u32, &T>(&value)) });
        } else if type_id == TypeId::of::<Pointer>() {
            let value = ManuallyDrop::new(Self::read_relative_ptr(reader)?);
            
            result = Some(unsafe { read(transmute::<&Pointer, &T>(&value)) });
        } else if type_id == TypeId::of::<String>() {
            let value = ManuallyDrop::new(Self::read_str(reader)?);
            
            result = Some(unsafe { read(transmute::<&String, &T>(&value)) });
        } else {
            result = None;
        }
        
        Ok(result)
    }
    
    fn read_unk_std_vec<T, R: Reader>(self, reader: &mut R, read_content: impl Fn(&mut R) -> Result<T>) -> Result<Option<Vec<T>>> {
        Ok(Some(Self::read_vec(reader, read_content)?))
    }
    
    fn read_unk_std_box<T, R: Reader>(self, _reader: &mut R, _read_content: impl Fn(&mut R) -> Result<T>) -> Result<Option<Box<T>>> {
        Ok(None)
    }
    
    fn read_box<T, R: Reader>(self, reader: &mut R, parser: impl FnOnce(&mut R, Self) -> Result<T>) -> Result<Option<T>> {
        let ptr = Self::read_relative_ptr(reader)?;
        
        if ptr.value() == 0 {
            return Ok(None)
        }
        
        scoped_reader_pos!(reader); // jump to pointer will be undone in destructor
        reader.set_position(ptr)?;
        
        Ok(Some(parser(reader, self)?))
    }
}

impl<C: HeapCategory> CanRead<String> for FormatCgfx<C> {
    fn read(self, reader: &mut impl Reader) -> Result<String> {
        Self::read_str(reader)
    }
}
// ... more CanRead implementations

impl<C: HeapCategory> WriteDomain for FormatCgfx<C> {
    type Pointer = Pointer;
    type Cat = C;

    fn write_unk<T: 'static>(self, ctx: &mut impl vivibin::WriteCtx, value: &T) -> Result<Option<()>> {
        let type_id = TypeId::of::<T>();
        
        // this can be auto generated by a macro super easily
        // this should also hopefully? get otimized out
        // at least once TypeId::of becomes a stable const fn
        if type_id == TypeId::of::<i32>() {
            let value = unsafe { transmute::<&T, &i32>(value) };
            Self::write_i32(ctx, *value)?;
            Ok(Some(()))
        } else if type_id == TypeId::of::<u32>() {
            let value = unsafe { transmute::<&T, &u32>(value) };
            Self::write_u32(ctx, *value)?;
            Ok(Some(()))
        } else if type_id == TypeId::of::<Pointer>() {
            let value = unsafe { transmute::<&T, &Pointer>(value) };
            Self::write_relative_ptr(ctx.cur_writer(), *value)?;
            Ok(Some(()))
        } else if type_id == TypeId::of::<String>() {
            let value = unsafe { transmute::<&T, &String>(value) };
            Self::write_str(ctx, value)?;
            Ok(Some(()))
        } else {
            Ok(None)
        }
    }
    
    fn apply_reference(self, writer: &mut impl Writer, heap_offset: usize) -> Result<()> {
        Self::write_relative_ptr(writer, heap_offset.into())
    }
}

impl<C: HeapCategory> CanWrite<i32> for FormatCgfx<C> {
    fn write(self, ctx: &mut impl WriteCtx, value: &i32) -> Result<()> {
        Self::write_i32(ctx, *value)
    }
}
impl<C: HeapCategory> CanWrite<u32> for FormatCgfx<C> {
    fn write(self, ctx: &mut impl WriteCtx, value: &u32) -> Result<()> {
        Self::write_u32(ctx, *value)
    }
}
impl<C: HeapCategory> CanWrite<String> for FormatCgfx<C> {
    fn write(self, ctx: &mut impl WriteCtx, value: &String) -> Result<()> {
        Self::write_str(ctx, value)
    }
}

#[derive(Debug, Clone, Readable)]
struct Vec3 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}

impl<D: WriteDomain> Writable<D> for Vec3 {
    fn to_writer(&self, ctx: &mut impl WriteCtx, domain: D) -> Result<()> {
        if domain.write_unk::<f32>(ctx, &self.x)?.is_none() {
            self.x.to_writer(ctx, domain)?;
        }
        if domain.write_unk::<f32>(ctx, &self.y)?.is_none() {
            self.y.to_writer(ctx, domain)?;
        }
        if domain.write_unk::<f32>(ctx, &self.z)?.is_none() {
            self.z.to_writer(ctx, domain)?;
        }
        Ok(())
    }
}

#[derive(Debug, Readable)]
#[allow(dead_code)]
struct SimpleNpc {
    #[require_domain]
    name: String,
    position: Vec3,
    is_visible: bool,
}

#[derive(Debug)]
#[allow(dead_code)]
struct Npc {
    name: String,
    position: Vec3,
    // future proc macro?: #[args(BoolSize::U32)]
    is_visible: bool,
    
    item_ids: Vec<u32>,
}

impl<D: CanRead<String>> Readable<D> for Npc {
    fn from_reader<R: Reader>(reader: &mut R, domain: D) -> Result<Self> {
        let name = domain.read(reader)?;
        let position = domain.read_fallback::<Vec3>(reader)?;
        let is_visible = domain.read_fallback::<bool>(reader)?;
        let item_ids: Vec<u32> = domain.read_std_vec::<u32, R>(reader)?
            .ok_or_else(|| anyhow!("ReadDomain does not implement read_std_vec"))?;
        
        Ok(Npc {
            name,
            position,
            is_visible,
            item_ids,
        })
    }
}

impl<D: WriteDomain> Writable<D> for Npc {
    fn to_writer(&self, ctx: &mut impl WriteCtx, domain: D) -> Result<()> {
        // TODO: should I add a special case for &str
        // TODO: explicit trait bound
        if domain.write_unk::<String>(ctx, &self.name)?.is_none() {
            panic!(); // String does not have a default implementation
        }
        domain.write_fallback::<Vec3>(ctx, &self.position)?;
        domain.write_fallback::<bool>(ctx, &self.is_visible)?;
        // TODO: add better convenience for this
        domain.write_fallback(ctx, &(self.item_ids.len() as u32))?;
        let item_ids_token = ctx.allocate_next_block(|ctx| {
            for value in &self.item_ids {
                domain.write_fallback::<u32>(ctx, value)?;
            }
            Ok(())
        })?;
        ctx.write_token::<4>(item_ids_token)?;
        Ok(())
    }
}

fn main() -> Result<()> {
    const VEC3_BYTES: [u8; 52] = [
        // name ptr
        0x1c, 0, 0, 0,
        // position vec3
        0, 0, 0x80, 0x3f, 0, 0, 0, 0x40, 0, 0, 0, 0x3f,
        // isvisible
        1, 0, 0, 0,
        // item_ids
        3, 0, 0, 0, 0x10, 0, 0, 0,
        // child
        // 0x10, 0, 0, 0,
        // name string
        0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x57, 0x6f, 0x72, 0x6c, 0x64, 0,
        // item_ids values
        0x1, 0, 0, 0, 0x4, 0, 0, 0, 0x8, 0, 0, 0, 
        
        // // child
        // // name ptr
        // 0x18, 0, 0, 0,
        // // position vec3
        // 0, 0, 0, 0x40, 0, 0, 0x80, 0x3f, 0, 0, 0, 0x3f,
        // // isvisible
        // 0, 0, 0, 0,
        // // child
        // 0, 0, 0, 0,
        // // name string
        // 0x48, 0x69, 0x69, 0x69, 0x69, 0x69, 0, 0,
    ];
    
    let mut cursor: Cursor<&[u8]> = Cursor::new(&VEC3_BYTES);
    let npc = Npc::from_reader(&mut cursor, FormatCgfx::<()>::default())?;
    println!("Hello World {:?}", npc);
    
    let mut ctx = FormatCgfx::<()>::new_ctx();
    npc.to_writer(&mut ctx, FormatCgfx::<()>::default())?;
    println!("Written {:#x?}", &ctx.to_buffer(FormatCgfx::<()>::default(), None));
    Ok(())
}
