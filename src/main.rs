use core::{
    any::TypeId,
    marker::PhantomData,
    mem::{transmute, ManuallyDrop},
    ptr::read,
};
use std::io::{Cursor, Write};

use anyhow::Result;
use vivibin::{
    pointers::PointerZero32, scoped_reader_pos, CanRead, CanReadVec, CanWrite, CanWriteBox,
    CanWriteSlice, EndianSpecific, Endianness, HeapCategory, ReadDomain, ReadDomainExt,
    ReadVecFallbackExt, Readable, Reader, SimpleWritable, Writable, WriteCtx, WriteDomain,
    WriteDomainExt, WriteSliceFallbackExt, Writer,
};

// typedef for more convenient access
type Pointer = PointerZero32;

#[derive(Clone, Default)]
struct FormatCgfx<C: HeapCategory>(PhantomData<C>); // cgfx is an actual data type btw and the main reason I did this (3DS related)

impl<C: HeapCategory> FormatCgfx<C> {
    pub fn read_i32(reader: &mut impl Reader) -> Result<i32> {
        let mut bytes: [u8; 4] = Default::default();
        reader.read_exact(&mut bytes)?;
        
        Ok(match Self::default().endianness() {
            Endianness::Little => i32::from_le_bytes(bytes),
            Endianness::Big => i32::from_be_bytes(bytes),
        })
    }
    
    pub fn write_i32(ctx: &mut impl WriteCtx, value: i32) -> Result<()> {
        let bytes = match Self::default().endianness() {
            Endianness::Little => value.to_le_bytes(),
            Endianness::Big => value.to_be_bytes(),
        };
        
        ctx.write_all(&bytes)?;
        Ok(())
    }
    
    pub fn read_u32(reader: &mut impl Reader) -> Result<u32> {
        let mut bytes: [u8; 4] = Default::default();
        reader.read_exact(&mut bytes)?;
        
        Ok(match Self::default().endianness() {
            Endianness::Little => u32::from_le_bytes(bytes),
            Endianness::Big => u32::from_be_bytes(bytes),
        })
    }
    
    pub fn write_u32(ctx: &mut impl WriteCtx, value: u32) -> Result<()> {
        let bytes = match Self::default().endianness() {
            Endianness::Little => value.to_le_bytes(),
            Endianness::Big => value.to_be_bytes(),
        };
        
        ctx.write_all(&bytes)?;
        Ok(())
    }
    
    pub fn read_relative_ptr(reader: &mut impl Reader) -> Result<Pointer> {
        let pos = reader.position()?;
        let raw_ptr = u32::from_reader(reader, Self::default())?;
        Ok(if raw_ptr != 0 { Pointer::new(pos as u32 + raw_ptr) } else { Pointer::new(0) })
    }
    
    pub fn write_relative_ptr(writer: &mut impl Writer, value: Pointer) -> Result<()> {
        let relative = value.value() - writer.position()? as u32;
        relative.to_writer_simple(writer, &mut Self::default())?;
        Ok(())
    }
    
    pub fn read_str(reader: &mut impl Reader) -> Result<String> {
        // reads a boxed string and not an inline string despite read_boxed's existence
        // because inline strings are never used in this format so this is 100x a more
        // sensible default
        let ptr = Self::read_relative_ptr(reader)?;
        
        scoped_reader_pos!(reader); // jump to pointer will be undone in destructor
        reader.set_position(ptr)?;
        
        reader.read_c_str()
    }
    
    pub fn write_str(ctx: &mut impl WriteCtx, value: &str) -> Result<()> {
        let token = ctx.allocate_next_block(move |ctx| {
            ctx.write_c_str(value)?;
            Ok(())
        })?;
        
        ctx.write_token::<4>(token)?;
        Ok(())
    }
    
    pub fn read_vec<T, R: Reader>(reader: &mut R, read_content: impl Fn(&mut R) -> Result<T>) -> Result<Vec<T>> {
        let count = Self::read_u32(reader)?;
        let content = Self::default().read_box_nullable(reader, |reader| {
            let mut result = Vec::with_capacity(count as usize);
            
            for _ in 0..count {
                result.push(read_content(reader)?);
            }
            
            Ok(result)
        })?;
        
        Ok(content.unwrap_or_default())
    }
}

// https://github.com/rust-lang/rust/issues/26925
impl<C: HeapCategory> Copy for FormatCgfx<C> {}

impl<C: HeapCategory> EndianSpecific for FormatCgfx<C> {
    fn endianness(&self) -> Endianness {
        Endianness::Little
    }
}

impl<C: HeapCategory> ReadDomain for FormatCgfx<C> {
    type Pointer = Pointer;

    fn read_unk<T: 'static>(self, reader: &mut impl Reader) -> Result<Option<T>> {
        let result: Option<T>;
        // TODO: use ConstTypeId again
        let type_id = TypeId::of::<T>();
        
        // this can be auto generated by a macro super easily
        // this should also hopefully? get otimized out
        // at least once TypeId::of becomes a stable const fn
        if type_id == TypeId::of::<i32>() {
            let value = ManuallyDrop::new(Self::read_i32(reader)?);
            
            result = Some(unsafe { read(transmute::<&i32, &T>(&value)) });
        } else if type_id == TypeId::of::<u32>() {
            let value = ManuallyDrop::new(Self::read_u32(reader)?);
            
            result = Some(unsafe { read(transmute::<&u32, &T>(&value)) });
        } else if type_id == TypeId::of::<Pointer>() {
            let value = ManuallyDrop::new(Self::read_relative_ptr(reader)?);
            
            result = Some(unsafe { read(transmute::<&Pointer, &T>(&value)) });
        } else if type_id == TypeId::of::<String>() {
            let value = ManuallyDrop::new(Self::read_str(reader)?);
            
            result = Some(unsafe { read(transmute::<&String, &T>(&value)) });
        } else {
            result = None;
        }
        
        Ok(result)
    }
    
    fn read_box_nullable<T, R: Reader>(self, reader: &mut R, read_content: impl FnOnce(&mut R) -> Result<T>) -> Result<Option<T>> {
        let ptr = Self::read_relative_ptr(reader)?;
        
        if ptr.value() == 0 {
            return Ok(None)
        }
        
        scoped_reader_pos!(reader); // jump to pointer will be undone in destructor
        reader.set_position(ptr)?;
        
        Ok(Some(read_content(reader)?))
    }
}

impl<C: HeapCategory> CanReadVec for FormatCgfx<C> {
    fn read_std_vec_of<T, R: Reader>(self, reader: &mut R, read_content: impl Fn(&mut R) -> Result<T>) -> Result<Vec<T>> {
        Self::read_vec(reader, read_content)
    }
}

impl<C: HeapCategory> CanRead<String> for FormatCgfx<C> {
    fn read(self, reader: &mut impl Reader) -> Result<String> {
        Self::read_str(reader)
    }
}
// ... more CanRead implementations

impl<C: HeapCategory> WriteDomain for FormatCgfx<C> {
    type Pointer = Pointer;
    type Cat = C;

    fn write_unk<T: 'static>(&mut self, ctx: &mut impl vivibin::WriteCtx, value: &T) -> Result<Option<()>> {
        let type_id = TypeId::of::<T>();
        
        // this can be auto generated by a macro super easily
        // this should also hopefully? get otimized out
        // at least once TypeId::of becomes a stable const fn
        if type_id == TypeId::of::<i32>() {
            let value = unsafe { transmute::<&T, &i32>(value) };
            Self::write_i32(ctx, *value)?;
            Ok(Some(()))
        } else if type_id == TypeId::of::<u32>() {
            let value = unsafe { transmute::<&T, &u32>(value) };
            Self::write_u32(ctx, *value)?;
            Ok(Some(()))
        } else if type_id == TypeId::of::<Pointer>() {
            let value = unsafe { transmute::<&T, &Pointer>(value) };
            Self::write_relative_ptr(ctx.cur_writer(), *value)?;
            Ok(Some(()))
        } else if type_id == TypeId::of::<String>() {
            let value = unsafe { transmute::<&T, &String>(value) };
            Self::write_str(ctx, value)?;
            Ok(Some(()))
        } else {
            Ok(None)
        }
    }
    
    fn apply_reference(&mut self, writer: &mut impl Writer, heap_offset: usize) -> Result<()> {
        Self::write_relative_ptr(writer, heap_offset.into())
    }
}

impl<C: HeapCategory> CanWriteBox for FormatCgfx<C> {
    fn write_box_of<W: WriteCtx>(
        &mut self,
        ctx: &mut W,
        write_content: impl FnOnce(&mut Self, &mut W) -> Result<()>
    ) -> Result<()> {
        let token = ctx.allocate_next_block(|ctx| {
            write_content(self, ctx)
        })?;
        
        ctx.write_token::<4>(token)
    }
}

impl<C: HeapCategory> CanWriteSlice for FormatCgfx<C> {
    fn write_slice_of<T: 'static, W: WriteCtx>(
        &mut self,
        ctx: &mut W,
        values: &[T],
        write_content: impl Fn(&mut Self, &mut W, &T) -> Result<()>,
    ) -> Result<()> {
        (values.len() as u32).to_writer(ctx, self)?;
        let item_ids_token = ctx.allocate_next_block(|ctx| {
            for value in values {
                write_content(self, ctx, value)?;
            }
            Ok(())
        })?;
        ctx.write_token::<4>(item_ids_token)?;
        Ok(())
    }
}

impl<C: HeapCategory> CanWrite<i32> for FormatCgfx<C> {
    fn write(&mut self, ctx: &mut impl WriteCtx, value: &i32) -> Result<()> {
        Self::write_i32(ctx, *value)
    }
}
impl<C: HeapCategory> CanWrite<u32> for FormatCgfx<C> {
    fn write(&mut self, ctx: &mut impl WriteCtx, value: &u32) -> Result<()> {
        Self::write_u32(ctx, *value)
    }
}
impl<C: HeapCategory> CanWrite<str> for FormatCgfx<C> {
    fn write(&mut self, ctx: &mut impl WriteCtx, value: &str) -> Result<()> {
        Self::write_str(ctx, value)
    }
}
impl<C: HeapCategory> CanWrite<String> for FormatCgfx<C> {
    fn write(&mut self, ctx: &mut impl WriteCtx, value: &String) -> Result<()> {
        Self::write_str(ctx, value)
    }
}

#[derive(Debug, Clone, Readable, Writable)]
struct Vec3 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}

#[derive(Debug, Clone, Readable)]
#[boxed]
struct BoxedChild {
    id: u32,
    visible: bool,
}

impl<D: CanWriteBox> Writable<D> for BoxedChild {
    fn to_writer_unboxed(&self, ctx: &mut impl WriteCtx, domain: &mut D) -> Result<()> {
        domain.write_fallback(ctx, &self.id)?;
        domain.write_fallback(ctx, &self.visible)?;
        Ok(())
    }
    
    fn to_writer(&self, ctx: &mut impl WriteCtx, domain: &mut D) -> Result<()> {
        domain.write_box_of(ctx, |domain, ctx| {
            self.to_writer_unboxed(ctx, domain)
        })
    }
}

#[derive(Debug, Readable, Writable)]
#[allow(dead_code)]
#[extra_write_domain_deps(CanWriteBox)]
struct SimpleNpc {
    #[require_domain]
    name: String,
    position: Vec3,
    is_visible: bool,
    item_ids: Vec<u32>,
    child: BoxedChild,
}

#[derive(Debug)]
#[allow(dead_code)]
struct Npc {
    name: String,
    position: Vec3,
    // future proc macro?: #[args(BoolSize::U32)]
    is_visible: bool,
    
    item_ids: std::vec::Vec<u32>,
    
    child: BoxedChild,
}

impl<D: CanRead<String> + CanReadVec> Readable<D> for Npc {
    fn from_reader_unboxed<R: Reader>(reader: &mut R, domain: D) -> Result<Self> {
        let name = domain.read(reader)?;
        let position = domain.read_fallback::<Vec3>(reader)?;
        let is_visible = domain.read_fallback::<bool>(reader)?;
        let item_ids: Vec<u32> = domain.read_std_vec_fallback::<u32, R>(reader)?;
        // explicitly boxed (TODO: implement this into derive macro)
        // let child = domain.read_box::<BoxedChild, R>(reader, |reader| {
        //     BoxedChild::from_reader_unboxed(reader, domain)
        // })?;
        let child = domain.read_fallback::<BoxedChild>(reader)?;
        
        Ok(Npc {
            name,
            position,
            is_visible,
            item_ids,
            child,
        })
    }
}

impl<D: CanWrite<str> + CanWriteSlice + CanWriteBox> Writable<D> for Npc {
    fn to_writer_unboxed(&self, ctx: &mut impl WriteCtx, domain: &mut D) -> Result<()> {
        // TODO: i don't know how this could be implemented with derive
        // TODO: i also don't know if there is any benefit of this over String
        domain.write(ctx, &self.name)?;
        domain.write_fallback::<Vec3>(ctx, &self.position)?;
        domain.write_fallback::<bool>(ctx, &self.is_visible)?;
        domain.write_slice_fallback(ctx, &self.item_ids)?;
        // explicitly boxed
        // domain.write_box_of(ctx, |domain, ctx| {
        //     self.child.to_writer_unboxed(ctx, domain)
        // })?;
        domain.write_fallback(ctx, &self.child)?;
        Ok(())
    }
}

fn main() -> Result<()> {
    const BYTES: &[u8] = &[
        // name ptr
        0x20, 0, 0, 0,
        // position vec3
        0, 0, 0x80, 0x3f, 0, 0, 0, 0x40, 0, 0, 0, 0x3f,
        // isvisible
        1, 0, 0, 0,
        // item_ids
        3, 0, 0, 0, 0x14, 0, 0, 0,
        // child_ptr
        0x1c, 0, 0, 0,
        
        // name string
        0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x57, 0x6f, 0x72, 0x6c, 0x64, 0,
        // item_ids values
        0x1, 0, 0, 0, 0x4, 0, 0, 0, 0x8, 0, 0, 0, 
        
        // child
        // id
        0x18, 0, 0, 0,
        // visible
        1, 0, 0, 0,
    ];
    
    let mut cursor: Cursor<&[u8]> = Cursor::new(BYTES);
    let npc = SimpleNpc::from_reader(&mut cursor, FormatCgfx::<()>::default())?;
    println!("Hello World {npc:?}");
    
    let mut ctx = FormatCgfx::<()>::new_ctx();
    npc.to_writer(&mut ctx, &mut FormatCgfx::<()>::default())?;
    let written = ctx.to_buffer(&mut FormatCgfx::<()>::default(), None)?;
    println!("Written {written:x?}");
    assert_eq!(&written, &BYTES, "Serialization failure, result not matching");
    Ok(())
}
